# 项目报告

## 目录

- 项目任务
- 项目设计
- 人员分工
- 阶段划分
- 项目特色
- 项目总结

## 项目任务

1. 基础需求：**这一部分的内容中`Ver1.0`已经实现**
   1. 利用逆波兰表达式、栈等实现一个简单的计算器
   2. 对带有`+` `-` `*` `/` `(` `)` 的算术表达式求值
2. 附加需求：
   1. `sin` `cos` `pow` 等简单函数
3. 自己做的需求调整：**根据自己的想法优化代码框架，设计了`Ver2.0`**
   1. `pow` 函数用 `^` 算符替代
   2. 实现动态压缩括号
   3. 实现对所有简单一元函数的功能基础，设计了快速添加新的简单一元函数方法（详细查看`Readme.md`）

## 项目设计

### `Ver 1.0` 框架

> 将读入的字符串直接全部转为逆波兰表达式
>
> 再处理该逆波兰表达式，计算值
>
> 详细略

### `Ver 2.0` 框架

- 首先将`1.0`中 *“全部转为逆波兰表达式”* 这一步进行优化，改成了递归思路，将整个括号内的表达式动态计算出值来：

  - 当遇到括号时，提取该括号内的整个式子，并调用`calExpr()`计算整个式子的值，然后再将整个括号内的式子当作一个数字进行处理
  - 在这种设计结构下，函数也可以直接**当作值**来处理，具体方法为：
    - 函数`sin(expr)`在式子中的构成有三部分：
      1. 函数名`sin`
      2. 括号`(...)`
      3. 参数表达式`expr`
    - 我们需要做的是，通过函数名来**索引对应的函数方法**，提取**括号内的参数表达式**，**计算参数表达式**得到**参数值**，然后将**参数值**传入函数得到**函数返回值**，将**返回值**作为**值**参与外部算式的计算。
- 举个例子的话：

> 在计算这样一个式子的时候，其流程如下：
> 
> `1+2*(3*4+5)`
> 
> = `1+2*([3 4 * 5 +])`
> 
> = `1+2*17`
>
> = `[1 2 17 * +]`
> 
> = `35`

- 在函数的索引这一步，我设计了一个结构体：

```c
typedef struct MyFunction{
    double (* option)(double x);
    char * name;
} MyFun;
```

​		记录下一个函数的名字，还有对应的函数的**函数指针**，然后将这个结构体存入数组，就可以实现调用。

- 接下来，完成对函数的封装，则只需要调用`calExpr(expr)`就可用实现计算表达式`expr`的值了





## 人员分工

| 职务     | 姓名 | 学号   |
| -------- | ---- | ------ |
| 组织统筹 | Me   | 114514 |
| 框架设计 | Me   | 114514 |
| 函数填充 | Me   | 114514 |
| 测试     | Me   | 114514 |
| 版本迭代 | Me   | 114514 |
| 文档     | Me   | 114514 |

## 阶段划分

1. [3.23] 读题 | 完成`Ver1.0` | 测试`Ver1.0`
2. [3.24] 设计`Ver2.0`框架 | 完成`Ver2.0` | 测试`Ver2.0` | 写文档
3. [3.30] 不想写数分，所以写了一个`Ver3.0`

## 项目特色

见项目设计`Ver2.0`部分

较高内聚，较低耦合

## 项目总结

人早就已经是面向对象的形状了，虽然C++不好用，但感觉C更难用。

稍微尝试了以下qt，大概摸懂了使用方法，也感受到了正经工程中的面向对象该怎么弄。

不过因为懒得重构所以直接把C的代码塞进去了，实际上可用用面向对象包装的更优雅一些。
